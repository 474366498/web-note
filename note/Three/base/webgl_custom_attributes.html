<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  html , body{
    margin: 0;
  }
</style>
<body>
  <script type="x-shader/x-vertex" id="vertexshader">

			uniform float amplitude;

			attribute float displacement;

			varying vec3 vNormal;
			varying vec2 vUv;

			void main() {

				vNormal = normal;
				vUv = ( 0.5 + amplitude ) * uv + vec2( amplitude );

				vec3 newPosition = position + amplitude * normal * vec3( displacement );
				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			varying vec3 vNormal;
			varying vec2 vUv;

			uniform vec3 color;
			uniform sampler2D colorTexture;

			void main() {

				vec3 light = vec3( 0.5, 0.2, 1.0 );
				light = normalize( light );

				float dProd = dot( vNormal, light ) * 0.5 + 0.5;

				vec4 tcolor = texture2D( colorTexture, vUv );
				vec4 gray = vec4( vec3( tcolor.r * 0.3 + tcolor.g * 0.59 + tcolor.b * 0.11 ), 1.0 );

				gl_FragColor = gray * vec4( vec3( dProd ) * vec3( color ), 1.0 );

			}

		</script>
</body>

<script type="importmap" >
  {
    "imports" : {
      "three" : "../three/build/three.module.js" ,
      "plugins/" : "../three/jsm/"
    }
  }
</script>
<script type="module">
  import * as T from 'three'
  import { OrbitControls } from 'plugins/controls/OrbitControls.js'
  import Stats from 'plugins/libs/stats.module.js'
  console.log(T , Stats )
  var renderer , scene , camera , orbit , status ;
  let sphere , uniforms  ;
  let displacement , noise 

  init () 
  animate ()

  function init () {
    camera = new T.PerspectiveCamera(30,window.innerWidth / window.innerHeight,1,1e3) 
    camera.position.z = 300 
    
    scene = new T.Scene() 
    scene.background = new T.Color(0x050505)
    
    uniforms = {
      'amplitude' : { value : 1.0 } ,
      'color':{value : new T.Color(0xff2200)} ,
      'colorTexture':{ value : new T.TextureLoader().load('../three/textures/water.jpg')}
    }
    console.log(92,uniforms)
    uniforms['colorTexture'].value.wrapS = uniforms['colorTexture'].value.wrapT = T.RepeatWrapping
    const shaderMaterial = new T.ShaderMaterial({
      uniforms ,
      vertexShader : document.getElementById('vertexshader').textContent ,
      fragmentShader : document.getElementById('fragmentshader').textContent
    })
    console.log(shaderMaterial)
    const radius = 50 , segments = 128 , rings = 64 

    const geo = new T.SphereGeometry(radius,segments,rings) 

    displacement = new Float32Array(geo.attributes.position.count)
    noise = new Float32Array(geo.attributes.position.count) 

    for(let i = 0 ; i < displacement ; i++) {
      noise[i] = Math.random(  ) * 5
    }
    
    geo.setAttribute('displacement', new T.BufferAttribute(displacement , 1)) 
    sphere = new T.Mesh(geo,shaderMaterial)
    scene.add(sphere)

    const axes = new T.AxesHelper(1e3)
    scene.add(axes)

    renderer = new T.WebGLRenderer() 
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.setSize(window.innerWidth,window.innerHeight)
    
    document.body.appendChild(renderer.domElement) 

    status = new Stats()
    document.body.appendChild(status.dom) 
    orbit = new OrbitControls(camera,renderer.domElement) 
    orbit.addEventListener('change',handleOrbitChange)

    window.addEventListener('resize',handleWindowResize)


  }
  function handleOrbitChange () {
    render()
  }
  function handleWindowResize () {
    camera.aspect = window.innerWidth / window.innerHeight 
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth,window.innerHeight)
  }

  function animate() {
    requestAnimationFrame(animate)
    render() 
    status.update()
  }

  function render () {
    const time = Date.now() * 0.01 
    sphere.rotation.y = sphere.rotation.z = 0.01 * time 

    uniforms['amplitude'].value = 2.5 * Math.sin(sphere.rotation.y * .125) 
    uniforms['color'].value.offsetHSL(0.0005,0,0)

    for(let i = 0 ; i < displacement.length ; i++) {
      displacement[i] = Math.sin(.1 * i + time) 
      noise[i] += 0.5 * (0.5 - Math.random() )
      noise[i] = T.MathUtils.clamp(noise[i] , -5,5) 
      displacement[i] += noise[i]
    }
    sphere.geometry.attributes.displacement.needsUpdate = true 

    renderer.render(scene,camera)
  }

</script>
</html>