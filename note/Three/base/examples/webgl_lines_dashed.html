<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  </head>
  <style>
    body{
      margin:0;
    }
  </style>
  <body>
     
  </body>
  <script type="importmap">
    {
      "imports" : {
        "three" :"../../three/build/three.module.js" ,
        "plugins/":"../../three/jsm/"
      }
    }
  </script>
  <script type="module" >
    import * as T from 'three' 
    import Stats from 'plugins/libs/stats.module.js'
    import * as GeometryUtils from 'plugins/utils/GeometryUtils.js'
    import {OrbitControls } from 'plugins/controls/OrbitControls.js'
    console.log(T , OrbitControls)

    var webgl , scene , camera , stats 
    const objects = [] 
    const W = window.innerWidth , H = window.innerHeight 

    init() 
    animate()

    function init () {
      camera = new T.PerspectiveCamera(60,W/H,1,200) 
      camera.position.z = 150 

      scene = new T.Scene() 
      scene.background = new T.Color(0x111111) 
      scene.fog = new T.Fog(0x111111,150,200) 

      const subdivisions = 6 ,
            recursion = 1 
      const points = GeometryUtils.hilbert3D(new T.Vector3(0,0,0),25,recursion,0, 1, 2, 3, 4, 5, 6, 7)      
      const spline = new T.CatmullRomCurve3(points)

      const samples = spline.getPoints(points.length * subdivisions) 
      const geometrySpline = new T.BufferGeometry().setFromPoints(samples) 

      const line = new T.Line(geometrySpline,new T.LineDashedMaterial({color:0xffffff,dashSize : 1 , gapSize:.5}))

      objects.push(line) 
      scene.add(line) 

      const geometryBox = box(50,50,50)

      const lineSegments = new T.LineSegments(geometryBox, new T.LineDashedMaterial({color:0xffaa00,dashSize:3,gapSize:1})) 
      lineSegments.computeLineDistances() 
      objects.push(lineSegments)
      scene.add(lineSegments)

      scene.add(new T.AxesHelper(1e2))

      webgl = new T.WebGLRenderer({antialias : true }) 
      webgl.setPixelRatio(window.devicePixelRatio)
      webgl.setSize(W,H) 

      document.body.appendChild(webgl.domElement)

      stats = new Stats() 
      document.body.appendChild(stats.domElement) 

      window.addEventListener('resize',onWindowResize)
    }

    function box (w,h,d) {
      w = w / 2 
      h = h / 2 
      d = d / 2 
      const geo = new T.BufferGeometry()
      const position = [] 
      position.push(
        - w, - h, - d,
					- w, h, - d,

					- w, h, - d,
					w, h, - d,

					w, h, - d,
					w, - h, - d,

					w, - h, - d,
					- w, - h, - d,

					- w, - h, d,
					- w, h, d,

					- w, h, d,
					w, h, d,

					w, h, d,
					w, - h, d,

					w, - h, d,
					- w, - h, d,

					- w, - h, - d,
					- w, - h, d,

					- w, h, - d,
					- w, h, d,

					w, h, - d,
					w, h, d,

					w, - h, - d,
					w, - h, d
      )
      geo.setAttribute('position',new T.Float32BufferAttribute(position,3)) 
      return geo
    }
    function onWindowResize () {
      camera.aspect = window.innerWidth / window.innerHeight 
      camera.updateProjectionMatrix() 
      webgl.setSize(window.innerWidth,window.innerHeight)
    }
    function animate() {
      requestAnimationFrame(animate)
      render() 
      stats.update()
    }

    function render () {
      const time = Date.now() * .001 
      scene.traverse(obj => {
        if(obj.isLine) {
          obj.rotation.x = .25 * time 
          obj.rotation.y = .25 * time 
        }
      })
      webgl.render(scene,camera)
    }
  </script>
</html>