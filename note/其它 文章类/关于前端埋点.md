


#### 埋点上报方式 

##### 1. ajax 埋点上报

``` javascript 
/**
 * method ajax method 
 * url ajax 地址
 * data  ajax 传输数据 
 **/
function buryingPointAjax (method ,url,data) {
  return new Promise((res,rej) => {
    const xhr = new XMLHttpRequest() 
    xhr.open(method ,url,data)
    xhr.onreadystatechange = function () {
      res() // res rej 处理
    }
    xhr.send()
  })
}

```
>> 一般而言，埋点域名并不是当前域名，因此请求会存在跨域风险，且如果ajax配置不正确可能会浏览器拦截。因此使用ajax这类请求并不是万全之策。


##### 2. 特殊标签 埋点上报
> 因为埋点涉及到请求，因此我们需要保证script和link标签的src可以正常请求。 如果需要请求script和link，我们需要将标签 ** 挂载到页面 **上 
> img 标签 

  *** img兼容性好 ***
  *** 无需挂载到页面上，反复操作dom ***
  *** img的加载不会阻塞html的解析，但img加载后并不渲染，它需要等待Render Tree生成完后才和Render Tree一起渲染出来 ***
  *** 注：通常埋点上报会使用gif图，合法的 GIF 只需要 43 个字节 ***


##### 3. 基于Navigator.sendBeacon的埋点上报  
> Navigator.sendBeacon是目前通用的埋点上报方案，Navigator.sendBeacon方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。


#### 常见埋点行为

*** button *** 

``` javascript 

function clickButton (url ,data) {
  navigator.sendBeacon(url,data)
}

``` 

*** 页面停留 ***

``` javascript 

let url = '' // 上报地址 
let startTime = Date.now()
let currentTime = '' 

router.beforeEach((to,from,next) => {
  if(to) {
    currentTime = Date.now() 
    let stayTime = parseInt(currentTime - startTime) 
    navigator.sendBeacon(url,{time:stayTime})
    startTime = Date.now()
  }
})


```
*** 错误监听 *** 

``` javascript 

// vue错误捕获 
app.config.errorHandler = err => {
  navigator.sendBeacon(url,{error,text:'vue错误捕获'})
}

// JS异常与静态资源加载异常
window.addEventListener('error',(error) => {
  navigator.sendBeacon(url,{error,text:error.message ? 'js执行异常' : '资源加载异常'})
})

```
``` javascript 
// 请求错误捕获
axios.interceptors.response
.use(response=>{
  return response.code === 200 ? Promise.resolve(response) : Promise.reject(response)
},error=>{
  navigator.sendBeacon(url,{error,text:'axios 请求错误捕获 '})
})


```

``` javascript 
// 内容可见埋点

const observer = new IntersectionObserver(callback) // 观察器生成
observer.observer(document.getElementById(targetDom)) // 监听内容节点
function callback (data) {
  navigator.sendBeacon(url,{data,text:'内容节点可见埋点'})
}

```
