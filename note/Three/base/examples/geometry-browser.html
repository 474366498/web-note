<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  </head>
  <style>
    body{
      margin:0;
    }
  </style>
  <body>
     
  </body>
  <script type="importmap">
    {
      "imports" : {
        "three" :"../../three/build/three.module.js" ,
        "plugins/":"../../three/jsm/"
      }
    }
  </script>
  <script type="module" >
    import * as T from 'three' 
    import {
      BoxGeometry ,
      BufferGeometry ,
      CapsuleGeometry ,
      CircleGeometry ,
      Color ,
      ConeGeometry ,
      Curve ,
      CylinderGeometry ,
      DodecahedronGeometry ,
      DoubleSide ,
      ExtrudeGeometry ,
      Float32BufferAttribute ,
      Group ,
      IcosahedronGeometry ,
      LatheGeometry ,
      LineSegments ,
      LineBasicMaterial ,
      Mesh ,
      MeshPhongMaterial ,
      OctahedronGeometry ,
      PerspectiveCamera ,
      PlaneGeometry ,
      PointLight ,
      PointLightHelper ,
      RingGeometry ,
      Scene ,
      Shape ,
      ShapeGeometry,
      SphereGeometry ,
      TetrahedronGeometry ,
      TorusGeometry ,
      TorusKnotGeometry ,
      TubeGeometry ,
      Vector2 ,
      Vector3 ,
      WireframeGeometry ,
      WebGLRenderer
    } from 'three'
    import { GUI } from 'plugins/libs/lil-gui.module.min.js'
    import {OrbitControls } from 'plugins/controls/OrbitControls.js'
    console.log(T , OrbitControls)

    const twoPi = 2 * Math.PI 
    var options 

    class CustomSinCurve extends Curve {
      constructor (scale = 1) {
        super() 
        this.scale = scale
      }
      getPoint (t,optionalTarget = new Vector3()) {
        const tx = t * 3 - 1.5 
        const ty = Math.sin(2*Math.PI * t) 
        const tz = 0 

        return optionalTarget.set(tx,ty,tz).multiplyScalar(this.scale)
      }
    }
    
    function updateGroupGeometry (group,geo) {
      group.children[0].geometry.dispose()
      group.children[1].geometry.dispose()
      group.children[0].geometry = new WireframeGeometry(geo) 
      group.children[1].geometry = geo 
    }

    const x = 0 , y = 0 
    const heartShape = new Shape()
    heartShape.moveTo( x + 5, y + 5 );
    heartShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );
    heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7, x - 6, y + 7 );
    heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
    heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );
    heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );
    heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );

    const guis = {
      BoxGeometry : function (mesh) {
        const data = {
          width : 15 ,
          height:15 ,
          depth:15 ,
          widthSegments : 1 ,
          heightSegments : 1 ,
          depthSegments : 1
        }
        function generateGeometry() {
          updateGroupGeometry(mesh,new BoxGeometry(
            data.width ,
            data.height ,
            data.depth ,
            data.widthSegments ,
            data.heightSegments ,
            data.depthSegments
          ))
        }
        // console.log(124,gui.children.find(g=>g._title === 'THREE.BoxGeometry'))
        // if(!gui.children.find(g=>g._title === 'THREE.BoxGeometry')){

          const folder = gui.addFolder('THREE.BoxGeometry')
  
          Object.keys(data).forEach(key=>{
            // console.log(126,key)
            folder.add(data,key,1,['width','height','depth'].includes(key) ? 30 : 10 )
              .step(['width','height','depth'].includes(key) ? .1 : 1) 
              .onChange(generateGeometry)
          }) 
        // }
        generateGeometry()
      },
      CapsuleGeometry : function (mesh) {
        const data = {
          radius : 5 ,
          length : 5 ,
          capSegments : 10 ,
          radialSegments : 20 
        }

        function generateGeometry () {
          updateGroupGeometry(mesh,new CapsuleGeometry(
            data.radius ,
            data.length ,
            data.capSegments ,
            data.radialSegments 
          ))
        }

        const folder = gui.addFolder('THREE.CapsuleGeometry')
        Object.keys(data).forEach(key => {
          folder.add(data,key,1,['radius','length'].includes(key) ? 30 : 32 )
          .step(['radius','length'].includes(key) ? .1 : 1)
          .onChange(generateGeometry)
        })
        generateGeometry()
      },
      CylinderGeometry : function (mesh) {
        const data = {
          radiusTop : 5 ,
          radiusBottom:5 ,
          height : 10 ,
          radialSegments : 8 ,
          heightSegments : 1 ,
          openEnded : false ,
          thetaStart : 0 ,
          thetaLength : twoPi
        }

        function generateGeometry () {
          updateGroupGeometry(mesh,new CylinderGeometry(
            data.radiusTop ,
            data.radiusBottom,
            data.height ,
            data.radialSegments,
            data.heightSegments ,
            data.openEnded ,
            data.thetaStart ,
            data.thetaLength
          ))
        }

        const folder = gui.addFolder('THREE.CylinderGeometry')

        Object.keys(data).forEach(key => {
          if(key !== 'openEnded') {
            if(/^theta/.test(key)) {
              console.log('pi')
              folder.add(data,key,0,twoPi).onChange(generateGeometry)
            }else {
              console.log('n')
              folder.add(
                data,
                key,
                /^height/.test(key) ? 1 : /^radial/.test(key) ? 3 : 0 ,
                /ents$/.test(key) ? 64 : 50 
              )
              .step(/ents$/.test(key) ? 1 : .1)
              .onChange(generateGeometry)
            }
            // folder.add(data,key,[])
          }else {
            folder.add(data,key).onChange(generateGeometry)
          }
        })
        generateGeometry ()
      } ,

      ConeGeometry : function (mesh) {
        const data = {
          radius : 5 ,
          height : 10 ,
          radialSegments : 8 ,
          heightSegments : 1 ,
          openEnded : false ,
          thetaStart : 0 ,
          thetaLength : twoPi 
        }

        function generateGeometry () {
          updateGroupGeometry(mesh,new ConeGeometry(
            data.radius ,
            data.height ,
            data.radialSegments ,
            data.heightSegments ,
            data.openEnded ,
            data.thetaStart ,
            data.thetaLength
          ))
        }

        const folder = gui.addFolder('THREE.ConeGeometry')

        Object.keys(data).forEach(key => {
          if(key !== 'openEnded') {
            if(/^theta/.test(key)) {
              console.log('pi')
              folder.add(data,key,0,twoPi).onChange(generateGeometry)
            }else {
              console.log('n')
              folder.add(
                data,
                key,
                /^height/.test(key) ? 1 : /^radial/.test(key) ? 3 : 0 ,
                /ents$/.test(key) ? 64 : 50 
              )
              .step(/ents$/.test(key) ? 1 : .1)
              .onChange(generateGeometry)
            }
            // folder.add(data,key,[])
          }else {
            folder.add(data,key).onChange(generateGeometry)
          }
        })

        generateGeometry()

      },

      CircleGeometry : function (mesh) {

        const data = {
          radius : 10 ,
          segments : 32 ,
          thetaStart : 0 ,
          thetaLength : twoPi
        }

        function generateGeometry () {
          updateGroupGeometry(mesh , new CircleGeometry(
            data.radius ,
            data.segments ,
            data.thetaStart ,
            data.thetaLength
          ))
        }
        
        const folder = gui.addFolder('THREE.CircleGeometry')
        folder.add(data,'radius',1,20).onChange(generateGeometry)
        folder.add(data,'segments',0,128).step(1).onChange(generateGeometry)
        folder.add(data,'thetaStart',0,twoPi).onChange(generateGeometry)
        folder.add(data,'thetaLength',0,twoPi).onChange(generateGeometry)
        
        generateGeometry()

      },

      DodecahedronGeometry : function (mesh) {
        const data = {
          radius : 10 ,
          detail : 0
        }

        function generateGeometry() {
          updateGroupGeometry(mesh , new DodecahedronGeometry(data.radius,data.detail))
        }

        const folder = gui.addFolder('THREE.DodecahedronGeometry')
        folder.add(data,'radius',1,20).onChange(generateGeometry)
        folder.add(data,'detail',1,8).step(1).onChange(generateGeometry)

        generateGeometry() 
      } ,

      IcosahedronGeometry : function (mesh) {
        const data = {
          radius : 10 ,
          detail : 0
        }

        function generateGeometry () {
          updateGroupGeometry(mesh,new IcosahedronGeometry(data.radius,data.detail))
        }
        const folder = gui.addFolder('THREE.IcosahedronGeometry')
        folder.add(data,'radius',1,20).onChange(generateGeometry)
        folder.add(data,'detail',1,8).step(1).onChange(generateGeometry)
        generateGeometry()
      },

      LatheGeometry : function (mesh) {
        const points = [] 
        for(let i = 0 ; i < 10 ; i++) {
          points.push(new Vector2(Math.sin(i*.2) * 10 + 5 , (i-5) * 2))
        }
        const data = {
          segments : 12 , 
          phiStart : 0 ,
          phiLength : twoPi 
        }

        function generateGeometry () {
          const geo = new LatheGeometry(points , data.segments , data.phiStart , data.phiLength)
          updateGroupGeometry(mesh,geo)
        }

        const folder = gui.addFolder('THREE.LathGeometry')
        folder.add(data,'segments',1,30).onChange(generateGeometry)
        folder.add(data,'phiStart',0,twoPi).onChange(generateGeometry)
        folder.add(data,'phiLength',0,twoPi).onChange(generateGeometry)
        generateGeometry()

      },

      OctahedronGeometry : function (mesh) {

        const data = {
          radius : 10 ,
          detail : 0
        }
        function generateGeometry () {
          updateGroupGeometry(mesh,new OctahedronGeometry(data.radius,data.detail))
        }
        
        const folder = gui.addFolder('THREE.OctahedronGeometry')
        folder.add(data,'radius',1,20).onChange(generateGeometry)
        folder.add(data,'detail',0,10).step(1).onChange(generateGeometry)
        generateGeometry()
      },

      PlaneGeometry : function (mesh) {

        const data = {
          width : 10 ,
          height : 10 ,
          widthSegments : 1 ,
          heightSegments : 1 
        }
        function generateGeometry (){
          updateGroupGeometry(mesh,new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments))
        }
        const folder = gui.addFolder('THREE.PlaneGeometry')
        Object.keys(data).forEach(key => {
          folder.add(data,key,1,20).step(1).onChange(generateGeometry)
        })
        generateGeometry()
      },
      RingGeometry : function (mesh) {
        const data = {
          innerRadius : 5 ,
          outerRadius : 10 ,
          thetaSegments : 8 ,
          phiSegments : 8,
          thetaStart : 0 ,
          thetaLength : twoPi 
        }

        function generateGeometry () {
          updateGroupGeometry(mesh,new RingGeometry(
            data.innerRadius ,
            data.outerRadius  ,
            data.thetaSegments ,
            data.phiSegments ,
            data.thetaStart ,
            data.thetaLength
          ))
        }

        const folder = gui.addFolder('THREE.RingGeometry')
        Object.keys(data).forEach(key => {
          folder.add(
            data,
            key,
            ['thetaStart','thetaLength'].includes(key) ? 0 : 1 , 
            ['thetaStart','thetaLength'].includes(key) ? twoPi : 30 
          )
          .step(/Segments$/.test(key) ? 1 : .01)
          .onChange(generateGeometry)
        })

        generateGeometry()
      },

      SphereGeometry : function (mesh) {
        const data ={
          radius : 15 ,
          widthSegments : 32, 
          heightSegments : 24 ,
          phiStart : 0, 
          phiLength : twoPi ,
          thetaStart : 0,
          thetaLength : Math.PI 
        }

        function generateGeometry() {
            updateGroupGeometry(mesh , new SphereGeometry(
              data.radius ,
              data.widthSegments ,
              data.heightSegments ,
              data.phiStart ,
              data.phiLength ,
              data.thetaStart ,
              data.thetaLength
            ))
        }

        const folder = gui.addFolder('THREE.SphereGeometry')

        Object.keys(data).forEach(key => {
          folder.add(
            data,
            key,
            ['radius','widthSegments','heightSegments',].includes(key) ? 3 : 0 ,
            ['radius','widthSegments','heightSegments',].includes(key) ? 32 : twoPi
          )
          .step(['widthSegments','heightSegments',].includes(key) ? 1 : .01)
          .onChange(generateGeometry)
        })

        generateGeometry()

      } ,

      TetrahedronGeometry : function (mesh) {
        const data = {
          radius : 10 ,
          detail : 0
        }

        function generateGeometry () {
          updateGroupGeometry(mesh,new TetrahedronGeometry(data.radius,data.detail))
        }

        const folder = gui.addFolder('THREE.TetrahedronGeometry')
        Object.keys(data).forEach(key => {
          folder.add(
              data,
              key,
              key ==='radius' ? 1 : 0 , 
              key === 'radius' ? 30 : 5
            )
            .step(key =='radius' ? .1 : 1) 
            .onChange(generateGeometry)
        })

        generateGeometry()
      },
      TorusGeometry : function (mesh) {
        
        const data = { 
          radius : 10 ,
          tube : 3 ,
          radialSegments : 16 ,
          tubularSegments : 100 ,
          arc :twoPi 
        }

        function generateGeometry () {
          updateGroupGeometry(mesh , new TorusGeometry(
            data.radius ,
            data.tube ,
            data.radialSegments ,
            data.tubularSegments ,
            data.arc
          ))
        }
        const folder = gui.addFolder('THREE.TorusGeometry')
        folder.add(data,'radius',1,20).onChange(generateGeometry)
        folder.add(data,'tube',.1,10).onChange(generateGeometry)
        folder.add(data,'radialSegments',2,30).step(1).onChange(generateGeometry)
        folder.add(data,'tubularSegments',3,200).step(1).onChange(generateGeometry)
        folder.add(data,'arc',.1,twoPi).onChange(generateGeometry)
        console.log(501,folder)
        generateGeometry()
      },

      TorusKnotGeometry : function (mesh) {

        const data = {
          radius : 10 ,
          tube : 3 ,
          tubularSegments : 64 ,
          radialSegments : 8 ,
          p : 2 ,
          q : 3 
        }

        function generateGeometry () {
          updateGroupGeometry(
            mesh ,
            new TorusKnotGeometry(
              data.radius ,
              data.tube ,
              data.tubularSegments ,
              data.radialSegments ,
              data.p,
              data.q
            )
          )
        }

        const folder = gui.addFolder('THREE.TorusKnotGeometry')
        folder.add(data,'radius',1,20)
        folder.add(data,'tube',.1,20)
        folder.add(data,'tubularSegments',3,300) 
        folder.add(data,'radialSegments',3,30)
        folder.add(data,'p',1,20).step(1)
        folder.add(data,'q',1,20).step(1)

        folder?.children.forEach(d=>{
          if(['tubularSegments','radialSegments'].includes(d.property )) {
            d._step = 1 
          }
          d._onChange = generateGeometry
        })
        console.log(folder , folder.children)
        generateGeometry()
      },

      TubeGeometry : function (mesh) {

        const data = {
          segments : 20 ,
          radius : 2 ,
          radialSegments : 8 
        }

        const path = new CustomSinCurve(10)

        function generateGeometry () {
          updateGroupGeometry(mesh,new TubeGeometry(path,data.segments , data.radius , data.radialSegments))
        }
        const folder = gui.addFolder('THREE.TubeGeometry')
        Object.keys(data).forEach(key => {

          folder.add(data,key,1, key === 'radius' ? 10 : key =='segments' ? 100 : 20 ).step(/nts$/.test(key) ? 1 : .1).onChange(generateGeometry)
        })

        generateGeometry()
      },
      ShapeGeometry : function (mesh) {

        const data = {
          segments : 12
        }

        function generateGeometry () {
          const geometry = new ShapeGeometry(heartShape,data.segments) 
          geometry.center()
          updateGroupGeometry(mesh,geometry)
        }
        
        const folder = gui.addFolder('THREE.ShapeGeometry')
        folder.add(data,'segments',1,100).step(1).onChange(generateGeometry)

        generateGeometry()
      },
      ExtrudeGeometry : function (mesh) {
        const data = {
          steps : 2 ,
          depth : 16 ,
          bevelEnabled : true ,
          bevelThickness : 1 ,
          bevelSize : 1 ,
          bevelOffset : 0 ,
          bevelSegments : 1
        }
        const length = 12 , width  = 8  

        const shape = new Shape () 
        shape.moveTo(0,0) 
        shape.lineTo(0,width) 
        shape.lineTo(length , width)
        shape.lineTo(length , 0 )
        shape.lineTo(0,0)

        function generateGeometry () {
          const geo = new ExtrudeGeometry(shape,data)
          geo.center()
          updateGroupGeometry(mesh,geo)
        }
        const folder = gui.addFolder('THREE.ExtrudeGeometry')

        folder.add(data,'steps',1,10).step(1)
        folder.add(data,'depth',1,20)
        folder.add(data,'bevelEnabled')
        folder.add(data,'bevelThickness',1,5).step(1)
        folder.add(data,'bevelSize',0,5).step(1)
        folder.add(data,'bevelOffset',-4,5).step(1)
        folder.add(data,'bevelSegments',1,5).step(1)

        folder.children.forEach(d => {
          d._onChange = generateGeometry
        })

        generateGeometry()
      }


    }

    function chooseFromHash (mesh) {
      const selectedGeometry = window.location.hash.substring(1) || 'ExtrudeGeometry'
      console.log('chooseFromHash',selectedGeometry , window.location )
      if(guis[selectedGeometry] ) {
        guis[selectedGeometry](mesh)
      }
      if(selectedGeometry === 'TextGeometry'){
        return {fixed:true}
      }
      return {}
    }

    const selectedGeometry = window.location.hash.substring(1) 
    



    const gui = new GUI()
    const select = gui.addFolder('THREE.Geo选择器')
    const geoType = {
      type : ''
    }
    let geoData = Object.keys(guis)
    select.add(geoType,'type',geoData).onChange(val=>{
      console.log(val , guis[val],gui.children)
      gui.children.forEach(g=>{
        if(g!==select) {
          g.destroy()
        }
      })
      guis[val] && group && guis[val](group)
      options = val === 'TextGeometry' ? {fixed:true} : {}
    })

    const scene = new Scene() 
    scene.background = new Color(0x444444)
    scene.add(new T.AxesHelper(500)) 

    const camera = new PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,500) 
    camera.position.z = 30

    const webgl = new WebGLRenderer({antialias:true})
    webgl.setPixelRatio(window.devicePixelRatio)
    webgl.setSize(window.innerWidth,window.innerHeight) 
    document.body.appendChild(webgl.domElement) 

    const orbit = new OrbitControls(camera,webgl.domElement)
    // orbit.enableZoom = false 

    const lights = [] 
    lights[0] = new PointLight(0xffffff,1,0)
    lights[1] = new PointLight(0xffffff,1,0)
    lights[2] = new PointLight(0xffffff,1,0)
    
    lights[0].position.set(0,200,0)
    lights[1].position.set(100,200,100)
    lights[2].position.set(-100,-200,-100)
    
    lights.forEach(light=>{
      scene.add(light)
      scene.add(new PointLightHelper(light))
    })

    const group = new Group() 

    const geometry = new BufferGeometry() 
    geometry.setAttribute('position',new Float32BufferAttribute([],3)) 

    const lineMaterial = new LineBasicMaterial({color:0xffffff,transparent:true , opacity:.5}) 
    const meshMaterial = new MeshPhongMaterial({color:0x156289,emissive:0x072534,side:DoubleSide,flatShading:true})

    group.add(new LineSegments(geometry,lineMaterial))
    group.add(new Mesh(geometry,meshMaterial))

    scene.add(group) 
   
    options = chooseFromHash(group)

    render() 

    function render () {
      requestAnimationFrame(render) 
      if(!options.fixed){
        group.rotation.x += .005
        group.rotation.y += .005
      }
      webgl.render(scene,camera)
    }

    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth / window.innerHeight 
      camera.updateProjectionMatrix() 
      webgl.setSize(window.innerWidth , window.innerHeight)
    },false)
  </script>
</html>