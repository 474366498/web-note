

[!文章来源](https://mp.weixin.qq.com/s/xNaR8UDU8wQpAq7RmBrDGA)
[!github](https://github.com/GuJiugc/JueJinDemo)

``` javascript 

import axios from 'axios' 

let instance = axios.create({
  baseURL : '/api/'
})

// 发布订阅
class EventEmitter {
  constructor(){
    this.event = {}
  }

  on(type,cbRes,cbRej) {
    if(!this.event[type]) {
      this.event[type] = [ [cbRes,cbRej] ]
    }else {
      this.event[type].push([cbRes,cbRej])
    }
  }

  emit (type,res,ansType) {
    if(this.event[type]) {
      this.event[type].forEach(cbArray=>{
        if(ansType === 'resolve') {
          cbArray[0](res)
        }else {
          cbArray[1](res)
        }
      }) 
    }
  }

}


// 根据请求生成对应的key
function generateReqKey (config,hash) {
  const {method , url , params ,data} = config 
  return [ method ,url , JSON.stringify(params) , JSON.stringify(data),hash].join('&')
}
//是否是文件上传接口
function isFileUpload (config) {
  return Object.prototype.toString.call(config.data) === '[object FormData]'
}

// 存储已发送但未响应的请求
const pendingRequest = new Set() 
// 发布订阅容器
const ev = new EventEmitter()

// 添加请求拦截器
instance.interceptors.request.use(async config => {
  let hash = location.hash 
  let reqKey = generateReqKey(config,hash) 

  if(!isFileUpload(config) && pendingRequest.has(reqKey)) {
    let res = null 
    try {
      res = await new Promise((resolve,reject) => {
        ev.on(reqKey,resolve,reject)
      })
      return Promise.reject({
        type :'limitResSuccess' ,
        val : res 
      })
    }catch(limitFunErr) {
      return Promise.reject({
        type :'limitResError' ,
        val : limitFunErr
      })
    }
  }else {
    config.pendKey = reqKey 
    pendingRequest.add(reqKey)
  }
  return config 
},function (error) {
  return Promise.reject(error)
})


// 添加响应拦截器
instance.interceptors.response.use(function (response) {
  handleSuccessResponse_limit(response)
  return response
},function (error) {
  return handleErrorResponse_limit(error)
})


// 接口响应成功
function handleSuccessResponse_limit(response) {
  const reqKey = response.config.pendKey 
  if(pendingRequest.has(reqKey)) {
    let x = null 
    try {
      x = JSON.parse(JSON.stringify(response))
    }catch(e) {
      x = response
    }
    pendingRequest.delete(reqKey) 
    ev.emit(reqKey,x,'resolve')
    delete ev.reqKey
  }
}

// 接口响应失败
function handleErrorResponse_limit (error) {
  if(error.type && error.type === 'limitResSuccess') {
    return Promise.resolve(error.val)
  }else if(error.type && error.type === 'limitResError') {
    return Promise.reject(error.val)
  }else {
    let reqKey = error.config.pendKey 
    if(pendingRequest.has(reqKey)) {
      let x = null 
      try {
        x = JSON.parse(JSON.stringify(error))
      } catch(e){
        x = error
      }
      pendingRequest.delete(reqKey) 
      ev.emit(reqKey,x,'reject')
      delete ev.reqKey
    }
  }
  return Promise.reject(error)
}

export default instance 

```