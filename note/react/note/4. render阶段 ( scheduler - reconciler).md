

[!React17源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)](https://juejin.cn/post/7019254208830373902)


## 触发更新

*** 触发更新的方式 ReactDOM.render setState forUpdate hooks 中的useState ***

![更新流程.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bc6c901d9344035a53b5035f535adb7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

root为null ReactDOM.render => legacyRenderSubtreeIntoContainer => (root === null) => legacyCreateRootFromDOMContainer => updateContainer => requestEventTime => requestUpdateLane => createUpdate => enqueueUpdate => scheduleUpdateOnFiber

root不为null ReactDOM.render => legacyRenderSubtreeIntoContainer => (root !== null) =>  updateContainer => requestEventTime => requestUpdateLane => createUpdate => enqueueUpdate => scheduleUpdateOnFiber

#### legacyRenderSubtreeIntoContainer 
> react-dom/src/client/ReactDOMLegacy.js

``` typescript 
// packages/react-dom/src/client/ReactDOMLegacy.js

function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: Container,
  forceHydrate: boolean,
  callback: ?Function,
) {
  // ...
  let root: RootType = (container._reactRootContainer: any);
  let fiberRoot;
  if (!root) {
    // 首次渲染时根节点不存在
    // 通过 legacyCreateRootFromDOMContainer 创建根节点、fiberRoot 和 rootFiber
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // 非批量执行更新流程
    unbatchedUpdates(() => {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // 批量执行更新流程
    updateContainer(children, fiberRoot, parentComponent, callback);
  }
  return getPublicRootInstance(fiberRoot);
}

```


#### updateContainer  
  1. requestEventTime 获取更新触发的时间
  2. requestUpdateLane 获取当前任务优先级
  3. createUpdate 创建更新
  4. enqueueUpdate 将任务推进更新队列
  5. scheduleUpdateOnFiber 调度更新

``` typescript 

// packages/react-dom/src/client/ReactDOMLegacy.js

export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  // ...
  const current = container.current;
  const eventTime = requestEventTime(); // 获取更新触发的时间
  // ...
  const lane = requestUpdateLane(current); // 获取任务优先级

  if (enableSchedulingProfiler) {
    markRenderScheduled(lane);
  }

  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  // ...

  const update = createUpdate(eventTime, lane); // 创建更新任务
  update.payload = {element};

  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    // ...
    update.callback = callback;
  }

  enqueueUpdate(current, update); // 将任务推入更新队列
  scheduleUpdateOnFiber(current, lane, eventTime); // schedule 进行调度

  return lane;
}


```


#### setState 
![setState更新流程.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de0bd64a06f24c52a301e9a378f9783b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

setState => updater.enqueueSetState => requestEventTime => requestUpdateLane => createUpdate=>enqueueUpdate => scheduleUpdateOnFiber 

class组件在原型链上定义了setState 调用触发器updater上的 enqueueSetState 

``` typescript

// packages/react/src/ReactBaseClasses.js

Component.prototype.setState = function(partialState, callback) {
  invariant(
    typeof partialState === 'object' ||
      typeof partialState === 'function' ||
      partialState == null,
    'setState(...): takes an object of state variables to update or a ' +
      'function which returns an object of state variables.',
  );
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

``` 
updater上定义的enqueueSetState 和 updateContainer 都是触发后续的更新调度

``` typescript 
// packages/react-reconciler/src/ReactFiberClassComponent.old.js

const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime(); // 获取更新触发的时间
    const lane = requestUpdateLane(fiber); // 获取任务优先级

    const update = createUpdate(eventTime, lane); // 创建更新任务
    update.payload = payload;
    if (callback !== undefined && callback !== null) {
      if (__DEV__) {
        warnOnInvalidCallback(callback, 'setState');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update); // 将任务推入更新队列
    scheduleUpdateOnFiber(fiber, lane, eventTime); // schedule 进行调度
    // ...

    if (enableSchedulingProfiler) {
      markStateUpdateScheduled(fiber, lane);
    }
  },
  // ...
};


```

#### forceUpdate 
![forceUpdate更新.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/378f9ebb90824805ad7c44789be1173c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

forceUpdate => updater.enqueueForceUpdate => requestEventTime => requestUpdateLane => createUpdate => enqueueUpdate => scheduleUpdateOnFiber 

forceUpdate 调用触发器updater 上的enqueueForceUpdate , enqueueForceUpdate同样是触发一系列的更新流程

``` typescript 
reconciler/src/ReactFiberClassComponent.old.js

const classComponentUpdater = {
  isMounted,
  // ...
  enqueueForceUpdate(inst, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime(); // 获取更新触发的时间
    const lane = requestUpdateLane(fiber); // 获取任务优先级

    const update = createUpdate(eventTime, lane); // 创建更新
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      if (__DEV__) {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update); // 将任务推进更新队列
    scheduleUpdateOnFiber(fiber, lane, eventTime); // 触发更新调度
    // ...

    if (enableSchedulingProfiler) {
      markForceUpdateScheduled(fiber, lane);
    }
  },
};


```

## 创建更新任务

*** ReactDOM.render setState forceUpdate 最后殊途同归 都会走流程图中 requestEventTime 到 scheduleUpdateOnFiber 这一流程，去创建更新任务 *** 

#### 获取更新触发时间
react 执行更新过程中，会将更新任务拆解，每一帧优先执行高优先级任务，从而保证用户体验的流畅
react 通过requestEventTime 方法去创建一个currentEventTime 用于标识更新任务触发的时间，对于相同时间的任务，会批量执行。同样优先级的任务，currentEventTime值越小，就会越早执行

``` typescript 
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

export function requestEventTime() {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) { // 判断当前react是否处在计算或提交更新阶段
    // 在 react 执行过程中，直接返回当前时间
    return now();
  }
  // 如果不在 react 执行过程中
  if (currentEventTime !== NoTimestamp) {
    // 正在执行浏览器事件，返回上次的 currentEventTime
    return currentEventTime;
  }
  // react 中断后首次更新，计算新的 currentEventTime
  currentEventTime = now();
  return currentEventTime;
}
``` 

在requestEventTime 中 *** (executionContext & (RenderContext | CommitContext)) *** 做了二进制计算 RenderContext 代表正在计算更新 CommitContext 代表react 正在提交更新

``` typescript 
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

export const NoContext = /*             */ 0b0000000;
const BatchedContext = /*               */ 0b0000001;
const EventContext = /*                 */ 0b0000010; // 18.0 没有这三个了
const DiscreteEventContext = /*         */ 0b0000100; // 18.0 没有这三个了
const LegacyUnbatchedContext = /*       */ 0b0001000; // 18.0 没有这三个了
const RenderContext = /*                */ 0b0010000;
const CommitContext = /*                */ 0b0100000;
export const RetryAfterError = /*       */ 0b1000000;

let executionContext: ExecutionContext = NoContext;

``` 
requestEvent 做的事情如下
  1. 在 react的render和commit阶段直接获取更新任务的触发时间，并抹平相差10ms以内的更新任务 以便于批量执行
  2. 当 currentEventTime 不等于 NoTimestamp时，则判断其正在执行浏览器事件，react想要同样优先级的更新任务保持相同的时间，所以直接返回上次的currentEventTime 
  3. 如果是react 上次中断之后的首次更新，那就给currentEventTime赋予一个新值


#### 划分更新任务优先级
requestUpdateLane 

``` typescript  version 17
// packages/react-reconciler/src/ReactFiberWorkLoop.old.js 

export function requestUpdateLane(fiber: Fiber): Lane {
  // ...

  // 根据记录下的事件的优先级，获取任务调度的优先级
  const schedulerPriority = getCurrentPriorityLevel();

  // ...
  let lane;
  if (
    (executionContext & DiscreteEventContext) !== NoContext &&
    schedulerPriority === UserBlockingSchedulerPriority
  ) {
    // 如果是用户阻塞级别的事件，则通过InputDiscreteLanePriority 计算更新的优先级 lane
    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
  } else {
    // 否则依据事件的优先级计算 schedulerLanePriority
    const schedulerLanePriority = schedulerPriorityToLanePriority(
      schedulerPriority,
    );
    
    if (decoupleUpdatePriorityFromScheduler) {
      const currentUpdateLanePriority = getCurrentUpdateLanePriority();

    // 根据计算得到的 schedulerLanePriority，计算更新的优先级 lane
    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
  }

  return lane;
}

```

``` typescript version 18 
export function requestUpdateLane(fiber: Fiber): Lane {
  // Special cases
  const mode = fiber.mode;
  // 要符合这个if mode 一定是 0 => ConcurrentMode是1 NoMode是0 
  if ((mode & ConcurrentMode) === NoMode) {
    return (SyncLane: Lane);
  } else if (
    !deferRenderPhaseUpdateToNextBatch &&
    (executionContext & RenderContext) !== NoContext &&
    workInProgressRootRenderLanes !== NoLanes
  ) {
    /*
    这是渲染阶段的更新。这些都不是官方支持的。旧的行为是给这个相同的“线程”(车道)当前正在渲染的内容。如果你在组件上调用setState稍后在同一渲染中发生，它将刷新。想情况下，我们想要去掉特殊情况，把它们当作来自交错的事件。无论如何，这种模式并没有得到官方的支持。这种行为只是一种退路。这面旗帜只会在我们能滚之前存在抛出setState警告，因为现有代码可能会意外依赖当前行为。
    */
    return pickArbitraryLane(workInProgressRootRenderLanes);
  }

  const isTransition = requestCurrentTransition() !== NoTransition;
  if (isTransition) {
    if (__DEV__ && ReactCurrentBatchConfig.transition !== null) {
      const transition = ReactCurrentBatchConfig.transition;
      if (!transition._updatedFibers) {
        transition._updatedFibers = new Set();
      }

      transition._updatedFibers.add(fiber);
    }
    // 对于同一事件中具有相同优先级的所有更新，将更新分配给通道的算法应该是稳定的。要做到这一点，算法的输入必须相同。我们使用的技巧是将这些输入中的第一个缓存到事件中。然后在确定事件结束后重置缓存的值。我们的启发式是当我们进入一个并发工作循环时
    if (currentEventTransitionLane === NoLane) {
      // 同一事件中的所有转换都被分配到相同的通道
      currentEventTransitionLane = claimNextTransitionLane();
    }
    return currentEventTransitionLane;
  }

  //在某些React方法中发起的更新，如flushSync，通过使用上下文变量跟踪它来设置优先级。主机配置返回的不透明类型在内部是一个通道，所以我们可以直接使用它。TODO:将此类型转换移动到事件优先级模块。
  const updateLane: Lane = (getCurrentUpdatePriority(): any);
  if (updateLane !== NoLane) {
    return updateLane;
  }

  // This update originated outside React. Ask the host environment for an
  // appropriate priority, based on the type of event.
  // The opaque type returned by the host config is internally a lane, so we can
  // use that directly.
  // TODO: Move this type conversion to the event priority module.

  //此更新源自React外部。根据事件类型向主机环境请求适当的优先级。主机配置返回的不透明类型在内部是一个通道，所以我们可以直接使用它。TODO:将此类型转换移动到事件优先级模块。
  const eventLane: Lane = (getCurrentEventPriority(): any);
  return eventLane;
}


``` 


#### 创建更新对象
createUpdate 基于 eventTime(requestEventTime()// 获取更新触发的时间),lane(requestUpdateLane(fiber) // 获取任务优先级) 创建更新对象

``` typescript 
// packages/react-reconciler/src/ReactUpdateQueue.old.js

export function createUpdate(eventTime: number, lane: Lane): Update<*> {
  const update: Update<*> = {
    eventTime, // 更新要出发的事件
    lane, // 优先级
    tag: UpdateState, // 指定更新的类型，0更新 1替换 2强制更新 3捕获性的更新
    payload: null, // 要更新的内容，例如 setState 接收的第一个参数
    callback: null, // 更新完成后的回调
    next: null, // 指向下一个更新
  };
  return update;
}

``` 

#### 关联 fiber 的更新队列
创建好update对象之后，紧接调用enqueueUpdate方法把update对象放到关联的fiber的updateQueue队列中 (classComponentUpdater )

``` typescript version 17
// packages/react-reconciler/src/ReactUpdateQueue.old.js

export function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {
  // 获取当前 fiber 的更新队列
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    // 若 updateQueue 为空，表示 fiber 还未渲染，直接退出
    return;
  }

  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;
  const pending = sharedQueue.pending;
  if (pending === null) {
    // pending 为 null 时表示首次更新，创建循环列表
    update.next = update;
  } else {
    // 将 update 插入到循环列表中
    update.next = pending.next;
    pending.next = update;
  }
  sharedQueue.pending = update;

  // ...
}


``` 

``` typescript version 18 
// packages/react-reconciler/src/ReactUpdateQueue.old.js

export function enqueueUpdate<State>(
  fiber: Fiber,
  update: Update<State>,
  lane: Lane,
) {
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    // Only occurs if the fiber has been unmounted.
    return;
  }

  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;
  // is Interleaved Update 是否是交叉更新状态
  if (isInterleavedUpdate(fiber, lane)) {
    const interleaved = sharedQueue.interleaved;
    if (interleaved === null) {
      // This is the first update. Create a circular list. 这是第一次更新创建循环列表
      update.next = update;
      // At the end of the current render, this queue's interleaved updates will
      // be transferred to the pending queue.
      // 在当前渲染结束时，此队列的交错更新将被传输到挂起队列.
      pushInterleavedQueue(sharedQueue);
    } else {
      update.next = interleaved.next;
      interleaved.next = update;
    }
    sharedQueue.interleaved = update;
  } else {
    const pending = sharedQueue.pending;
    if (pending === null) {
      // This is the first update. Create a circular list.
      update.next = update;
    } else {
      update.next = pending.next;
      pending.next = update;
    }
    sharedQueue.pending = update;
  }

  if (__DEV__) {
    if (
      currentlyProcessingQueue === sharedQueue &&
      !didWarnUpdateInsideUpdate
    ) {
      console.error(
        'An update (setState, replaceState, or forceUpdate) was scheduled ' +
          'from inside an update function. Update functions should be pure, ' +
          'with zero side-effects. Consider using componentDidUpdate or a ' +
          'callback.',
      );
      didWarnUpdateInsideUpdate = true;
    }
  }
}


```



## reconciler 过程
更新任务创建好了并关联到fiber 

####  根据任务类型执行不同更新
reconciler阶段会协调任务去执行，以scheduleUpdateOnFiber为入口函数，首先调用checkForNestedUpdates方法，检查嵌套的更新数量，若嵌套数量大于50层时，被认为是循环更新（无限更新） 此时抛出异常 避免了render函数中的死循环
然后通过 markUpdateLaneFromFiberToRoot 方法，向上递归更新fiber的lane ,lane的更新就是将当前任务lane与之前的lane进行二进制或运算叠加

``` typescript version 17

// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
  // 检查是否有循环更新
  // 避免例如在类组件 render 函数中调用了 setState 这种死循环的情况
  checkForNestedUpdates();
  
  // ...
  // 自底向上更新 child.fiberLanes
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);

  // ...
  // 标记 root 有更新，将 update 的 lane 插入到root.pendingLanes 中
  markRootUpdated(root, lane, eventTime);

  if (lane === SyncLane) { // 同步任务，采用同步渲染
    if (
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) {
      // 如果本次是同步更新，并且当前还未开始渲染
      // 表示当前的 js 主线程空闲，并且没有 react 任务在执行

      // ...
      // 调用 performSyncWorkOnRoot 执行同步更新任务
      performSyncWorkOnRoot(root);
    } else {
      // 如果本次时同步更新，但是有 react 任务正在执行
      
      // 调用 ensureRootIsScheduled 去复用当前正在执行的任务，让其将本次的更新一并执行
      ensureRootIsScheduled(root, eventTime);
      schedulePendingInteractions(root, lane);
      
      // ...
  } else {
    // 如果本次更新是异步任务
    
    // ... 
    // 调用 ensureRootIsScheduled 执行可中断更新
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  }

  mostRecentlyUpdatedRoot = root;
}


``` 

``` typescript version 18

// packages/react-reconciler/src/ReactFiberWorkLoop.old.js

export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
): FiberRoot | null {
  checkForNestedUpdates();

  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  if (root === null) {
    return null;
  }

  // Mark that the root has a pending update.
  markRootUpdated(root, lane, eventTime);

  if (
    (executionContext & RenderContext) !== NoLanes &&
    root === workInProgressRoot
  ) {
    // This update was dispatched during the render phase. This is a mistake if the update originates from user space (with the exception of local hook updates, which are handled differently and don't reach this function), but there are some internal React features that use this as an implementation detail, like selective hydration.
    // 这个更新是在渲染阶段发送的。如果更新来自用户空间(除了本地钩子更新，它们的处理方式不同，不会到达这个函数)，这是一个错误，但是有一些内部的React功能使用这个作为实现细节，比如选择性水化。
    warnAboutRenderPhaseUpdatesInDEV(fiber);

    // Track lanes that were updated during the render phase
    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
      workInProgressRootRenderPhaseUpdatedLanes,
      lane,
    );
  } else {
    // This is a normal update, scheduled from outside the render phase. For example, during an input event.
    // 这是一个正常的更新，从渲染阶段之外安排。例如，在输入事件期间。
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        addFiberToLanesMap(root, fiber, lane);
      }
    }

    warnIfUpdatesNotWrappedWithActDEV(fiber);

    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {
      if (
        (executionContext & CommitContext) !== NoContext &&
        root === rootCommittingMutationOrLayoutEffects
      ) {
        if (fiber.mode & ProfileMode) {
          let current = fiber;
          while (current !== null) {
            if (current.tag === Profiler) {
              const {id, onNestedUpdateScheduled} = current.memoizedProps;
              if (typeof onNestedUpdateScheduled === 'function') {
                onNestedUpdateScheduled(id);
              }
            }
            current = current.return;
          }
        }
      }
    }

    if (enableTransitionTracing) {
      const transition = ReactCurrentBatchConfig.transition;
      if (transition !== null) {
        if (transition.startTime === -1) {
          transition.startTime = now();
        }

        addTransitionToLanesMap(root, transition, lane);
      }
    }

    if (root === workInProgressRoot) {
      // TODO: Consolidate with `isInterleavedUpdate` check Received an update to a tree that's in the middle of rendering. Mark that there was an interleaved update work on this root. Unless the `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render phase update. In that case, we don't treat render phase updates as if they were interleaved, for backwards compat reasons.
      // 待办事项:合并' isInterleavedUpdate '检查收到一个更新到树，在渲染的中间。标记在这个根上有一个交错的更新工作。除非' deferRenderPhaseUpdateToNextBatch '标志是关闭的，这是一个渲染阶段更新。在这种情况下，出于向后比较的原因，我们不会将呈现阶段更新视为交错的。
      if (
        deferRenderPhaseUpdateToNextBatch ||
        (executionContext & RenderContext) === NoContext
      ) {
        workInProgressRootInterleavedUpdatedLanes = mergeLanes(
          workInProgressRootInterleavedUpdatedLanes,
          lane,
        );
      }
      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
        // The root already suspended with a delay, which means this render definitely won't finish. Since we have a new update, let's mark it as suspended now, right before marking the incoming update. This has the  effect of interrupting the current render and switching to the update.  TODO: Make sure this doesn't override pings that happen while we've  already started rendering.
        // 根已经挂起了一个延迟，这意味着这个渲染肯定不会完成。因为我们有一个新的更新，让我们把它标记为暂停，就在标记即将到来的更新之前。这有中断当前渲染并切换到更新的效果。待办事项:确保这不会覆盖我们已经开始渲染时 rendering
        markRootSuspended(root, workInProgressRootRenderLanes);
      }
    }

    ensureRootIsScheduled(root, eventTime); // performSyncWorkOnRoot 
    if (
      lane === SyncLane &&
      executionContext === NoContext &&
      (fiber.mode & ConcurrentMode) === NoMode &&
      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)
    ) {
      // Flush the synchronous work now, unless we're already working or inside
      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
      // scheduleCallbackForFiber to preserve the ability to schedule a callback
      // without immediately flushing it. We only do this for user-initiated
      // updates, to preserve historical behavior of legacy mode.
      resetRenderTimer();
      flushSyncCallbacksOnlyInLegacyMode();
    }
  }
  return root;
}


```
performSyncWorkOnRoot 主要做两件事 *** performSyncWorkOnRoot在ensureRootIsScheduled方法内 ***
  1. renderRootSync 从根节点开始同步渲染任务
  2. commitRoot 执行commit流程




#### workLoop

#### performUnitOfWork 

## scheduler 

#### 实现帧空闲调度任务

#### 任务中断