

## 性能优化 
![来自](https://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247491957&idx=1&sn=8c42a485aa8d940f2b46f62c079ccd8b&chksm=fc132323cb64aa35394560dcb891a1269ef881891bc7f8449ab7011c8fcf5f4bb886faddf25c&subscene=236&sessionid=-1932678242&key=fd7175669331615a56857047bb1a4c83567db5673800c2df5ff2cbfc50cdd2f7babc7359b4b8ec3066df44e0ff2331fc833927c077516dddee973ef1e6054d7f2ad8daf965f34ef252432b83e84ac567606f47710eb3cd33c723d40ba9349a0a9de472ee5f8572f0e31ac1ecb80def696e97ff94593f0001c1b962153896da4c&ascene=0&uin=ODI5Nzg2NTAy&devicetype=Windows+10+x64&version=63090217&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQMbqz1GS5zum7BP%2FQ3gvEnRLgAQIE97dBBAEAAAAAAFseDoJ4yQAAAAAOpnltbLcz9gKNyK89dVj0SGDG6eFzLH3Bl6yniiFpYlXKWw6VViF2HR5%2FCRTiX%2F%2FpadeI1KuajFBbhxfs2d81%2FqXw9bkhlczoMG7p3ykVvFuMdZQEJ51CDAzdzMX2f2OhKrLjQojoA%2BCG8SZacteJ8lf1RL3fkXvpfoQOpqJki35DZXJzP0C2Vyins1s16uNpi7q5eo5gh%2BUSeJu2B2GBG89PXHHGnkz%2Fa%2FBRVTdcrtHcUHJ%2FKYCz%2BhH5qXYRSWAyAnHMeZRPYK1C&acctmode=0&pass_ticket=V6FCGJ%2BAvdvEnG49%2BonBN%2FwDN7ADr%2FGnxdLhayfK31iLHDFJ9rPG8unBSi8m9lJBYcEhJu%2FE4eT6d8YUMnNN3A%3D%3D&wx_header=1#rd&scene=90)


### 1. 路由懒加载 

``` javascript 

// 通过webpackChunkName设置分割后代码块的名字
const Home = () => import(/* webpackChunkName: "home" */ "@/views/home/index.vue");
const MetricGroup = () => import(/* webpackChunkName: "metricGroup" */ "@/views/metricGroup/index.vue");
…………
const routes = [
    {
       path: "/",
       name: "home",
       component: Home
    },
    {
       path: "/metricGroup",
       name: "metricGroup",
       component: MetricGroup
    },
    …………
 ]

```
> 路由懒加载的原理 
>> 懒加载前提的实现:ES6 的动态加载模块 import() 
>>> webpackChunkName 作用是 webpack 在打包的时候，对异步引入的库代码（lodash）进行代码分割时，设置代码块的名字。webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中



### 2 组件懒加载 

``` vue 
// 老式的方式
<template>
  <div class="homeView">
    <p>home 页面</p>
    <el-button @click="dialogVisible = !dialogVisible">打开弹框</el-button>
    <dialogInfo v-if="dialogVisible" />
  </div>
</template>
<script>
import dialogInfo from '@/components/dialogInfo';
export default {
  name: 'homeView',
  components: {
    dialogInfo
  }
}
</script>

```

> 当用户打开页面时 会一次必加载页面所有的资源 
> 用懒加载的方式引入 

``` vue 

<script>
const dialogInfo = () => import(/* webpackChunkName: "dialogInfo" */ '@/components/dialogInfo');
export default {
  name: 'homeView',
  components: {
    dialogInfo
  }
}
</script>


```
  #### 组件懒加载的使用场景
  > 资源拆分得过细也不好，会造成浏览器http 请求过多
  使用场景
  1. 页面的JS文件体积大 导致页面打开慢，可以通过组件懒加载进行资源拆分，利用浏览器并行下载资源 提升下载速度(如首页)
  2. 组件不是一进入页面就展示 ， 需要一定条件才触发(如弹窗组件)
  3. 组件复用性高，很多页面都有引入，利用组件懒加载抽离出组件，一方面可以很好利用缓存 ，同时也可以减少页面的JS文件大小(如表格组件、图形组件)


### 3 合理使用 Tree shaking 

``` javascript 

// util.js
export function targetType(target) {
  return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
}
export function deepClone(target) {
  return JSON.parse(JSON.stringify(target));
}

```
> tree-shaking 原理：
>> 依赖于ES6的模块特性，ES6模板依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-thaking的基础
>> 静态分析就是不需要执行代码，就可以从字面量上对代码进行分析 ES6之前的模块化，比如 CommonJS 是动态加载，只有执行后才知道引用的什么模块，就不能通过静态分析去做优化，正是基于这个基础上，才使用tree-shaking成为了可能 

*** tree-shaking 并不是万能的 *** 

``` javascript 

// util.js
export default {
  targetType(target) {
    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
  },
  deepClone(target) {
    return JSON.parse(JSON.stringify(target));
  }
};

// 引入并使用
import util from '../util';
util.targetType(null)


```

>同样的，项目中只使用了 targetType 方法，未使用 deepClone 方法，项目打包后，deepClone 方法还是被打包到项目里 
>在打包后 dist 文件中导出时会导出一个方法对象 
>究其原因，export default 导出的是一个对象，*** 无法通过静态分析判断出一个对象的哪些变量未被使用，所以 tree-shaking 只对使用 export 导出的变量生效 ***


### 4 骨架屏优化白屏时长

#### why 

> SPA 单页应用，无论 vue 还是 react，最初的 html 都是空白的，需要通过加载 JS 将内容挂载到根节点上，这套机制的副作用：会造成长时间的白屏

#### 骨架屏插件

*** vue-skeleton-webpack-plugin *** 

  1. 安装 

    ``` npm i vue-skeleton-webpack-plugin ``` 

  2. vue.config.js 

  ``` javascript 

  const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin') 
  
  module.exports = {
    configureWebpack : {
      plugins : [
        new SkeletonWebpackPlugin({
          // 实例化插件对象
          webpackConfig : {
            entry : {
              app : path.join(__dirname , './src/skeleton.js') // 引入骨架屏入口文件
            }
          },
          minimize : true , // SPA 下是否需要压缩注入 HTML 的 JS 代码
          quiet:true ,   // 在服务端渲染时是否需要输出信息到控制台
          router : {
            mode : 'hash' ,  // 路由模式
            routes : [
              // 不同页面可以配置不同骨架屏
              // 对应路径所需要的骨架屏组件id，id的定义在入口文件内
              { path: /^\/home(?:\/)?/i, skeletonId: 'homeSkeleton' },
              { path: /^\/detail(?:\/)?/i, skeletonId: 'detailSkeleton' }
            ]
          }


        })
      ]
    }
  }


  
  ```

  3. skeleton.js 入口文件 

  ``` javascript 

     import Vue from 'vue' 
     // 引入对应的骨架屏页面
     import homeSkeleton from './views/homeSkeleton' 
     import detailSkeleton from './views/detailSkeleton' 

     export default new Vue({
      components : {
        homeSkeleton ,
        detailSkeleton 
      },
      template : `
        <homeSkeleton id='home' style='display:none' /> 
        <detailSkeleton id='detail' style='display:none' />
     
      `
     })


  ```

### 5 长列表虚拟滚动

  #### 虚拟滚动插件 
  > 虚拟滚动插件有很多 *** vue-virtual-scroller *** *** vue-virtual-scroll-list *** *** react-tiny-virtual-list *** *** react-virtualized *** 

  *** vue-virtual-sroller 示例 ***

  *** npm install vue-virtual-scroller ***

``` javascript 

  // main.js 
  import VueVirtualScroller from 'vue-virtual-scroller'
  import 'vue-virtual-srcoller/dist/vue-virtual-scroller.css' 

  Vue.use(VueVirtualScroller)
  
  <template>
    <RecycleScroller class='scroller' :items='list' :item-size='32' key-field='id' v-slot='{item}'>
      <div class='user'> {{ item.name}} </div>
    </RecycleScroller>
  </template>


```
> 该插件主要有 RecycleScroller.vue、DynamicScroller.vue 这两个组件，其中 RecycleScroller 需要 item 的高度为静态的，也就是列表每个 item 的高度都是一致的，而 DynamicScroller 可以兼容 item 的高度为动态的情况



### 6 Web Worker 优化长任务 

> 由于浏览器 GUI 渲染线程与 JS 引擎线程是互斥的关系，当页面中有很多长任务时，会造成页面 UI 阻塞，出现界面卡顿、掉帧等情况

``` javascript
  let sum = 0;
  for (let i = 0; i < 200000; i++) {
    for (let i = 0; i < 10000; i++) {
      sum += Math.random()
    }
  }

```
>  如果直接把下面这段代码直接丢到主线程中，计算过程中页面一直处于卡死状态，无法操作

*** 使用 Web Worker 执行上述代码时，计算过程中页面正常可操作、无卡顿 *** 

``` javascript 
// worker.js 

onmessage = function (e) {
  let sum = e.data 
  for(let i = 0 ; i < 2e6 ; i++) {
    for(let i = 0 ; i < 1e6 ; i++) {
      sum += Math.random()
    }
  }
  postMessage(sum)
}


```
 #### Web Worker 的通信时长
 
 > 并不是执行时间超过50ms 的任务 就可以使用 Web Worker 还要先考虑 *** 通信时长 *** 的问题 
 > 假如一个运算执行时长为100ms 但是通信时长为300ms 用web Worker 可能会更慢
 > 比如新建一个 web worker, 浏览器会加载对应的 worker.js 资源

*** 当任务的运算时长 - 通信时长 > 50ms，推荐使用 Web Worker *** 


### 7 requestAnimationFrame 制作动画 

> requestAnimationFrame 是浏览器专门为动画提供的API 它的刷新频率与显示器的频率保持一致，使用 requestAnimationFrame 可以解决 setTimeout / setInterval 制作动画卡顿的情况 

  1. 引擎层面
    > setTimeout / setInterval 属于 JS 引擎 , requestAnimationFrame 属于 GUI引擎 
    > JS引擎与GUI引擎是互斥的，也就是说 GUI 引擎在渲染时会阻塞 JS 引擎的计算

  2. 时间是否准确 
    > requestAnimationFrame 刷新频率是固定且准确的，但是 setTimeout / setInterval 是宏任务，根据事件轮询机制 ，其它任务会引起阻塞或延迟js任务的执行 会出现定时器不准的情况

  3. 性能层面 
    > 当页面被隐藏或最小化时 setTimeout / setInterval 定时器仍会在后台执行动画任务，而使用requestAnimationFrame 当页面处于未激活状态下，屏幕刷新任务会被系统暂停


### 8 JS的6种加载方式 

  1. 正常模式

  ``` <script src='index.js' ></script> ```

  > 这种情况下 JS 会阻塞 dom 渲染，浏览器必须等待 index.js 加载和执行完成后才能去做其它事情

  2. async 模式 
  
  ``` <script async src='index.js'> </script> ``` 
  
  > async 模式下 JS加载是异步， js 不会阻塞DOM的渲染 ， async 加载是无顺序的，当加载结束 js会立即执行
  *** 若js资源与dom元素没有依赖关系 也不会产生其他资源所需要的数据时 可以使用 async 模式 如理点统计 ***

  3. defer 模式
  
  ``` <script defer src='index.js'></script> ``` 
  > defer 模式下 js加载也是异步 defer 资源会在DOMContentLoaded 执行之前，并且 defer 是有顺序的加载
  > 如果有多个设置了 defer 的 script 标签存在,则会按照引入的前后顺序执行 即便是后面的 script 资源先返回
    >> 所以defer可以用来控制js文件的执行顺序 如element-ui 和 vue 因为element-ui 依赖于 vue 所有必须先引入 vue 再引入 element-ui 
  ``` javascript 
    <script defer src='vue.js'></script>
    <script defer src='element-ui.js'></script>

  ```  
  *** defer 使用场景 一般情况下都可以使用 defer 特别是需要控制资源加载顺序时 *** 

  4. module 模式 

  ``` <script type='module'> import {a} from './a.js' </script> ``` 
  
  > 在主流的现代浏览器中， script 标签的属性可以加上 type='module' , 浏览器会对其内部的 import 引用发起 http请求 ， 获取模块内容 ， 这时 script 的行为会像 defer 一样 ， 在后台下载 ， 并且等待DOM解析 
  > vite 就是利用浏览器支持原生的es module 模块 开发时跳过打包的过程 提升编译效率

  5. preload 

  ``` <link rel='preload' as='script' href='index.js'> ``` 

  > link 标签的preload属性：用于提前加载一些需要的依赖，这些资源会优先加载
  > vue2 项目打包生成的index.html文件，会自动给首页所需要的资源，全部添加preload 实现关键资源的提前加载

  *** preload 加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞onload事件 *** 
  *** preload 加载的JS脚本其加载和执行的过程是分离的，即preload 会加载相应的脚本代码，待到需要时自行调用 *** 

  6.prefetch 

  ``` <link rel='prefetch' as='script' href='index.js'> ``` 

  > prefetch 是利用浏览器的空闲时间 加载页面将来可能用到的资源的一种机制 ， 通常可以用于加载其他页面(非首页)所需要的资源，以便加快后续页面的打开速度 

  *** prefetch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少5分钟(无论资源是否可以缓存) *** 
  *** 当页面跳转时 未完成的prefetch 请求不会被中断 *** 

  #### 加载方式总结 

  *** async defer 是script标签的专属属性 ，对网页中的其它资源，可以通过link 的 preload prefetch 属性来预加载 *** 
  *** 现在框架已经将 preload prefetch 添加到打包流程中 通过灵活的配置，去使用这些预加载功能，同时也可以审时度势的向script标签中添加 async defer属性去处理资源 提交性能 *** 

### 9 图片优化 

  #### 图片的动态裁剪 

  很多云服务，比如阿里云或七牛云，都提供了图片的动态裁剪功能，效果很棒，确实是钱没有白花

  只需在图片的url地址上动态添加参数，就可以得到你所需要的尺寸大小，比如：http://7xkv1q.com1.z0.glb.clouddn.com/grape.jpg?imageView2/1/w/200/h/200

  图片瘦身前后对比：

  原图：1.8M

  裁剪后：12.8KB

  经过动态裁剪后的图片，加载速度会有非常明显的提升

  #### 图片懒加载

  > 图片懒加载实现原理 

  *** 由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性即可 *** 

  *** vue-lazyload 指令式 *** 

  ``` npm install vue-lazyload ``` 

  ``` javascript 
  import VueLazyload from 'vue-lazyload' 
  Vue.use(VueLazyload)
  // 配置项 
  Vue.use(VueLazyload, {
    preLoad : 1.3 ,
    error : 'dist/error.png' , // 图片加载失败的占位图
    loading : 'dist/loading.gif' , // 图片加载中的占位图
    attempt : 1 
  })

  <ul>
    <li v-for='img in list'> 
      <img v-lazy='img.src' :key='img.src' />
    </li>
  </ul>
  ```
  #### 使用字体图标

  *** iconfont *** 
  
  *** 轻量级：一个图标字体要比一系列的图像要小 一旦字体加载 图标马上就渲染出来 减少http 请求 *** 
  *** 灵活性：可以随意的该变颜色 产生阴影 透明效果 旋转... *** 
  *** 兼容性：几乎支持所有的浏览器 *** 

  #### 图片转base 64

  *** npm install  url-loader --save-dev *** 

  ``` javascript 

  // 配置 
  module.exports = {
    module : {
      rules : [{
        test : /.(png|jpg|gif)$/i ,
        use : [{
          loader :'url-loader' ,
          options : {
            // 小于10kb 的图片转为base64
            limit : 1024 * 10
          }
          }]
      }]
    }
  }


  ```


